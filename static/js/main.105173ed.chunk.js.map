{"version":3,"sources":["components/App.module.css","components/BitRow.tsx","bit.ts","circuitry.ts","add.ts","components/App.tsx","index.ts"],"names":["module","exports","BitRow","bits","cssCell","heading","numEmptyLeadingCells","renderBit","reversedBits","slice","reverse","range","map","num","className","key","bit","index","adjustedIndex","length","digits","join","parseInt","toDecimal","and","a","b","invert","nand","or","halfAdder","augend","addend","sum","carry","fullAdder","carryIn","first","second","flipBit","nextBits","ReactDOM","render","React","createElement","useState","inputA","setInputA","inputB","setInputB","output","result","push","add","styles","checked","onChange","type","document","getElementById"],"mappings":"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","file":"static/js/main.105173ed.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"bit\":\"App_bit__1ixWz\"};","import React from 'react';\nimport range from 'lodash/range';\nimport { Bit, toDecimal } from '../bit';\n\ntype Props = {\n  /**\n   * Array of bit values (0 or 1) making up a binary number. The least significant digit should be **_first_**.\n   */\n  bits: Bit[],\n  cssCell?: string,\n  heading: React.ReactNode,\n  numEmptyLeadingCells?: number,\n  renderBit: (bit: Bit, index: number) => React.ReactNode,\n}\n\nexport default function BitRow({ bits, cssCell, heading, numEmptyLeadingCells = 0, renderBit }: Props) {\n  // The least significant digit is first, which makes adding easier. However, we display the bits\n  // in the opposite order.\n  const reversedBits = bits.slice().reverse();\n\n  return (\n    <tr>\n      <th>{heading}</th>\n\n      {range(numEmptyLeadingCells).map(function (num) {\n        return <td className={cssCell} key={num}></td>;\n      })}\n\n      {reversedBits.map(function (bit, index) {\n        // The bits array has the least significant digit first. However, we display them in the\n        // reverse order, and must convert from the displayed index back to the bits index here.\n        const adjustedIndex = (bits.length - 1) - index;\n\n        return <td className={cssCell} key={index}>{renderBit(bit, adjustedIndex)}</td>;\n      })}\n\n      <td className={cssCell}>{toDecimal(bits)}</td>\n    </tr>\n  );\n}\n","export type Bit = 0 | 1;\n\n/**\n * Convert bits to a decimal number. Assumes that the least significant digit is **_first_**.\n */\nexport function toDecimal(bits: Bit[]): number {\n  // The least significant digits are first, which makes adding easier. However, we need the most\n  // significant digits first to convert to a number;\n  const reversed = bits.slice().reverse();\n  const digits = reversed.join('');\n  return parseInt(digits, 2);\n}\n","import type { Bit } from './bit';\n\nexport function and(a: Bit, b: Bit): Bit {\n  if (a) {\n    if (b) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nexport function invert(a: Bit): Bit {\n  if (a) { return 0; }\n  return 1;\n}\n\nexport function nand(a: Bit, b: Bit) {\n  return invert(and(a, b));\n}\n\nexport function or(a: Bit, b: Bit): Bit {\n  if (a) { return 1; }\n  if (b) { return 1; }\n  return 0;\n}\n\nexport function xor(a: Bit, b: Bit): Bit {\n  return nand(\n    nand(\n      a,\n      nand(a, b),\n    ),\n    nand(\n      nand(a, b),\n      b,\n    ),\n  );\n}\n","import { and, or, xor } from './circuitry';\nimport type { Bit } from './bit';\n\n// Add 2 1-bit numbers together.\nfunction halfAdder(augend: Bit, addend: Bit) {\n  return {\n    sum: xor(augend, addend),\n    carry: and(augend, addend),\n  };\n}\n\n// Add 3 1-bit numbers together, which allows us to add 2 1-bit numbers, plus any initial carry\n// (coming from a previous addition step).\nfunction fullAdder(a: Bit, b: Bit, carryIn: Bit) {\n  const first = halfAdder(a, b);\n  const second = halfAdder(carryIn, first.sum);\n  return {\n    sum: second.sum,\n    carry: or(first.carry, second.carry),\n  };\n}\n\n// Add two binary numbers together. The output will have one more bit than the inputs. For example,\n// an 8-bit number can be between 0 and 255. Adding two of them together gives us a number between\n// 0 and 510. To representt that sum, we need 9 bits.\nexport default function add(inputA: Bit[], inputB: Bit[]): Bit[] {\n  const output: Bit[] = [];\n  let carry: Bit = 0;\n\n  for (let index = 0; index < inputA.length; index ++) {\n    const result = fullAdder(inputA[index], inputB[index], carry);\n    output.push(result.sum);\n    carry = result.carry;\n  }\n\n  output.push(carry);\n  return output;\n}\n","import React, { useState } from 'react';\nimport BitRow from './BitRow';\nimport add from '../add';\nimport styles from './App.module.css';\nimport { invert } from '../circuitry';\nimport type { Bit } from '../bit';\n\nexport default function App() {\n  const [inputA, setInputA] = useState<Bit[]>([0, 0, 0, 0, 0, 0, 0, 0]);\n  const [inputB, setInputB] = useState<Bit[]>([0, 0, 0, 0, 0, 0, 0, 0]);\n  const output  = add(inputA, inputB);\n\n  return (\n    <table>\n      <caption>Binary adding machine</caption>\n      <thead>\n        <tr>\n          <th></th>\n          <th>8</th>\n          <th>7</th>\n          <th>6</th>\n          <th>5</th>\n          <th>4</th>\n          <th>3</th>\n          <th>2</th>\n          <th>1</th>\n          <th>0</th>\n          <th>Decimal representation</th>\n        </tr>\n      </thead>\n      <tbody>\n        <BitRow\n          bits={inputA}\n          cssCell={styles.bit}\n          heading=\"Input A\"\n          numEmptyLeadingCells={1}\n          renderBit={(bit, index) => <input checked={!!bit} onChange={() => setInputA(flipBit(index))} type=\"checkbox\" />}\n        />\n        <BitRow\n          bits={inputB}\n          cssCell={styles.bit}\n          heading=\"Input B\"\n          numEmptyLeadingCells={1}\n          renderBit={(bit, index) => <input checked={!!bit} onChange={() => setInputB(flipBit(index))} type=\"checkbox\" />}\n        />\n        <BitRow\n          bits={output}\n          cssCell={styles.bit}\n          heading=\"Sum\"\n          numEmptyLeadingCells={0}\n          renderBit={(bit) => !!bit ? 'âœ…' : null}\n        />\n      </tbody>\n    </table>\n  );\n}\n\nfunction flipBit(index: number) {\n  return function (bits: Bit[]) {\n    const nextBits = [...bits];\n    nextBits[index] = invert(nextBits[index]);\n    return nextBits;\n  };\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './components/App';\nimport './index.css';\n\nReactDOM.render(\n  React.createElement(App),\n  document.getElementById('root'),\n);\n"],"sourceRoot":""}